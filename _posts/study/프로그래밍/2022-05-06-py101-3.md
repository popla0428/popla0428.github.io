---
layout: post
title: /[Python 101/] Chap03 - 파이썬 자료구조
tags: [Python]
description: >
  (CLASS1O1의 'Python 101: 매일 30분, 40일 동안! LV. 1 파이썬 기초 프로젝트' 수업에 기반한 정리)
  Chap03 - 파이썬 리스트와 메서드, 튜플, 딕셔너리, 이차원 데이터 
related_posts:
  - _posts/study/프로그래밍/2022-05-06-py101-2.md
  - _posts/study/프로그래밍/2022-05-06-py101-4.md
sitemap: false
categories:
  - study
  - 프로그래밍
 # 글이 소속되는 카테고리 
 # 하단 글 작성에서 샾 하나짜리 (#) 제목 쓰면 위의 title 보다 더 우선 적용노출됨 
---

# [Python 101] Chap03 - 파이썬 자료구조

* toc 
{:toc .large-only}

## 자료구조  
![chap03-01](/assets/img/py101-03-table.png){: height="300" width='600' loading="lazy"}  

- 자료 구조는 여러 데이터 (타입: int, float, string)를 담을 수 있는 **바구니**와 같은 개념   
- 여러 데이터를 효과적으로 다룰 수 있는 것 (항만의 컨테이너 같은 것을 생각하면 됨)
- 파이썬에서는 기본 타입으로 제공됨  
- 다른 객체들의 컬렉션   

## 파이썬 리스트  
- 순서가 있고, 수정이 가능한 자료구조  
- 대괄호 `[]`를 사용하여 리스트에 넣고 싶은 값을 적어줌    
- 리스트를 사용하지 않는 경우와 비교  
  -  리스트를 사용하지 않는 경우  
~~~python
# 리스트를 사용하지 않는 경우 - 각 변수마다 값을 바인딩 시키는 형태
아이스크림1 = "월드콘" 
아이스크림2 = "메로나"
아이스크림3 = "스크류바"
~~~ 
![chap03-02](/assets/img/py101-03-list.png){: height="300" width='200' loading="lazy"}    
  
  - 리스트를 사용한 경우
    - 리스트의 원소 마다 인덱스가 있으며, 메모리에 이것이 먼저 할당됨 (**주소** 역할)  
    - 각 인덱스는 리스트의 원소 각각을 가리키게 됨 (원소가 메모리에 할당됨)
    - 인덱스라는 주소(위치)에 원소를 바인딩 시키는 것으로 이해해야 함  
    - 순서: 슬라이싱도 가능함  
    - 수정: 원소 값을 바꿀 수 있음 (인덱스, 슬라이스 사용)  
~~~python  
# 리스트를 사용한 경우 
아이스크림 = ["월드콘","메로나","스크류바"]
print(아이스크림[0])   # "월드콘"
print(아이스크림[0:2]) # "월드콘", "메로나"
~~~   
![chap03-03](/assets/img/py101-03-list2.png){: height="300" width='200' loading="lazy"}  
    - 추가: `append` 함수 사용. 리스트의 끝에 데이터가 추가됨 
~~~python  
리스트 = []
리스트.append("추가1")
리스트.append("추가2") 
print(리스트) # ["추가1","추가2"]
~~~   
    - 삽입: `insert(인덱스,원소)` 함수 사용. 원하는 위치에 원소 삽입
~~~python  
리스트 = ["e1","e2","e3"]
리스트.insert(2,"insert1")
print(리스트) # ["e1","e2","insert1","e3"]
~~~   
    - 삭제: `del 리스트[인덱스]` 함수 사용. 특정 인덱스에 있는 원소 삭제
~~~python  
리스트 = ["e1","e2","e3"]
del 리스트[2]
print(리스트) # ["e1","e2"]
~~~   
    - 확장: `extend` 함수 사용. 리스트의 끝에 다수의 아이템 추가 (+ 기능)
~~~python  
num = [1,2,3]
num.extend([4,5,6]) # [1,2,3] + [4,5,6] 과 동일
print(num) # [1,2,3,4,5,6]
~~~   

## 파이썬 리스트와 메서드  
### 최대,최소 - min, max  
### 정렬 - sorted
~~~python
xrp = [1,2,3,4]  

# 내장함수 sorted 쓰는 경우
xrp1 = sorted(xrp) # 오름차순
xrp2 = sorted(xrp, reverse = True) # 내림차순

# list의 메서드를 쓰는 경우 
xrp.sort() 
print(xrp)
~~~  
### 연결 - extend, +  
~~~python
ticker1 = ['a','b']  
ticker2 = ['c','d'] 
ticker = ticker1 + ticker2 # ticker1.extend(ticker2)
print(ticker) # ['a','b','c','d']  
~~~  

### 원소의 인덱스 찾기  

~~~python
tickers = ['a','b','c'] 
tickers.index('b') # 1
tickers.index('z') # ERROR
~~~  

### 연습문제  
* `close = [300,301,302,303,400]` 평균 계산  

~~~python
close = [300,301,302,303,400]
type(close)

mean = sum(close) / len(close)
print(mean) # 321.2
~~~

## 파이썬 튜플
- 순서가 있고, **수정은 불가능**한 자료구조  
  - 따라서, 자료구조 내의 **데이터 변경이 필요 없을 때** 튜플 사용함 
  - 대부분 리스트를 쓰지만, 위의 경우 튜플 사용하여 메모리 절약 가능함
- 괄호 `()`를 사용하여 리스트에 넣고 싶은 값을 적어줌    
~~~python
xrp = (1,2,3,4) # xrp = 1,2,3,4  
print(xrp) 
~~~     
  
  - 튜플을 사용한 경우
    - 튜플의 원소 마다 인덱스가 있으며, 메모리에 이것이 먼저 할당됨 (**주소** 역할)  
    - 각 인덱스는 튜플의 원소 각각을 가리키게 됨 (원소가 메모리에 할당됨)
    - 인덱스라는 주소(위치)에 원소를 바인딩 시키는 것으로 이해해야 함  
    - 순서: 슬라이싱도 가능함  
    - 수정: 불가능 (immutable type)

## 리스트와 튜플의 형변환  
- 리스트를 튜플로 형변환: `tuple()`
- 튜플을 리스트로 형변환: `list()`  

## 데이터 언패킹 (unpacking)  
~~~python
data = ('naver',10,17000,(2020,4,4))  
종목이름 = data[0] 
수량 = data[1]
현재가 = data[2]
날짜 = data[3]
~~~

### 한 번에 바인딩 시켜주기 
~~~python
# 한 번에 바인딩 시켜주기  
종목이름, 수량, 현재가, 날짜 = data 
print(종목이름) # 'naver'
~~~  

### 데이터가 많을 경우 `*` 사용하여 언패킹  
- 아래 예시에서 첫 원소가 나머지 원소와 바인딩 됨
~~~python 
vol = [2222,3333,4444,5555,6666,7777] 
last_vol,*trailing_vol = vol 
print(last_vol)
print(trailing_vol)
# 2222
# [3333, 4444, 5555, 6666, 7777]
~~~ 

## 파이썬 딕셔너리  
- 순서가 없고, 수정은 가능한 자료구조 
  - 순서가 없으므로 **인덱싱할 수 없음**
  - key를 통해서 인덱싱 해야 함
- **key, value를 쌍으로 저장**하는 자료구조
  - key를 통해서 value 값을 인덱싱   
  - `key:value` 쌍을 저장함   

~~~python
아이스크림 = {
  "가":2000,
  "나":1000,
  "다":800
}

print(아이스크림["가"]) # 2000
~~~

- key가 없는 경우의 인덱싱 - `get`
  - 딕셔너리는 없는 key를 통해 인덱싱하면 에러가 발생함
  - `get` 함수를 사용하면 key가 없는 경우 None을 리턴   

~~~python
아이스크림 = {
  "가":2000,
  "나":1000,
  "다":800
}

print(아이스크림.get('라ㅏ')) # None
~~~

- 수정이 가능하기 때문에 키 인덱싱 통한 수정, 값 추가, 삭제 가능  
  - `딕셔너리[키] = 값` 으로 원소 추가 가능 (별도의 함수 없음)
  - `del 딕셔너리[키]` 하면 key:value 쌍이 딕셔너리에서 삭제됨

### 연습문제  
* 리플의 2021-02-24일의 open, high, low, close를 key로 하여 가격을 딕셔너리로 표현.  

~~~python
price = {
  "open":535.0,
  "high":565.0,
  "low":510.0,
  "close":533.0
}

print(type(price)) # dict
print(price['close']) # 533.0
print(price.get('median')) # None
~~~   

## 딕셔너리 keys, values, in 함수 
~~~python
price = {
  "open":535.0,
  "high":565.0,
  "low":510.0,
  "close":533.0
}

price.keys() 
# dict_keys(['open', 'high', 'low', 'close'])

price.values() # 연산가능
# dict_values([535.0, 565.0, 510.0, 533.0])

'high' in price # True 
'median' in price # False 
~~~

### 연습문제  
* 2021년 월 별 상영 예정작 정보를 파이썬 딕셔너리로 표현하라.  

~~~python
movie = {
  "2021-05":['가','나','다','라'],  
  "2021-06":['마','바','사','아']   
}

movie['2021-05'][0]
~~~

## 파이썬 이차원 데이터 - 이차원 리스트
- 리스트 안의 리스트 구조로 이해하면 됨 (R의 리스트와 유사)  

~~~python
apart = [
  [101,102],
  [201,202],
  [301,302]
]

print(apart[0]) # [101,102]
~~~

- 이차원 리스트의 인덱싱 결과는 일차원 리스트 
  - 인덱싱 기호를 연속으로 붙여서 사용 
  - 2차원 리스트의 인덱싱 -> 1차원 리스트 -> 특정 원소  

~~~python
apart = [
  [101,102],
  [201,202],
  [301,302]
]

floor1 = apart[0]
print(floor1[0]) # 101
print(floor1[1]) # 102

print(apart[0][0]) # 101
print(apart[0][1]) # 102
~~~

### 연습문제  
* 이차원 리스트로 3일 동안의 리플의 시가,고가,저가,종가 표현  

~~~python  
price = [
  [1,2,3,3], # 24
  [4,5,6,6], # 25
  [7,8,9,9], # 26
]

# 26일 리플의 종가
print(price[2][3]) 
~~~  

* 위 문제를 딕셔너러리로 표현  

~~~python  
price = {
  "시가":[1,2,3],
  "고가":[8,9,10],
  "저가":[0,1,2],
  "종가":[10,9,8]
}

# 26일 리플의 시가 
print(price['시가'][2])
~~~  

- 이중 딕셔너리 구조로 표현도 가능 (편의상 숫자 1로 통일)  

~~~python  
price = {
  "시가":{
    "2021-02-24":1,
    "2021-02-25":1,
    "2021-02-26":1
  },
  "고가":{
    "2021-02-24":1,
    "2021-02-25":1,
    "2021-02-26":1
  },
  "저가":{
    "2021-02-24":1,
    "2021-02-25":1,
    "2021-02-26":1
  },
  "종가":{
    "2021-02-24":1,
    "2021-02-25":1,
    "2021-02-26":1
  } 
}

# 26일 리플의 시가 
print(price['시가']['2021-02-26'])
~~~
